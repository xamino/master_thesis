\chapter{Implementation}
\label{chap:Implementation}

In this chapter we will expand on the process of implementing our proof of concept.
Before we can discuss the actual work of implementing the architecture we need to define the developing environment.
This will include an introduction of the software libraries we will base some functionality of Tinzenite on.

\section{Tools and Environment}
\label{sec:Tools and Environment}

In this section we will discuss the tools we used to build the software proof of concept.
This includes libraries we utilized and the software used to write the programs.

\subsection{Golang}
\label{sub:Golang}

As previously stated the proof of concept implementation will be developed using the programming language Golang.
We will make full use of a range of features which we will briefly highlight in the following.

A Golang program will compile into a single native executable file.
Cross compilation is available to all major operating systems and processor architectures.
Unlike for example Java Golang does not depend on a virtual machine to run.
Golang is statically typed and garbage collected.
This gives us type safety and removes the need to manage the memory ourselves\footnote{Mostly. Care has to be taken to avoid needlessly creating some objects as discussed in section~\ref{TODO}}.
For a developer coming from Java a large standard library helps to ease the transition: Golang offers such a standard library.
We found writing Golang code to be less verbose than Java code for the same task while not being any harder to comprehend.

Different is the way errors are handled.
While in Java error handling is done via exceptions, Golang uses return values to signal errors.
This poses less of a problem than it may initially seem to as Golang functions can return multiple values.
Concurrency is also directly built into the language via so called \textit{"go routines"} and channels.
Unlike Java which builds objects with class inheritance, Golang uses composition and interfaces to build objects.
Building on this Golang does not even require the declaration of which interfaces an object implements -- having the method of an interface means that that object implements the interface.

Golang also lacks a few features, notably generics and function overloading.
We found these to be relatively trivial to work around, although the lack of generics leads to an increase in redundant boilerplate code.
A possibly higher hurdle is the lack of fine granular permissions: unlike Java Golang knows only private and public variables and functions, indicated by their name beginning with respectively a lowercase or a uppercase letter.

As to the development environment surrounding Golang only a few specifics should be noted.
A very nice feature is that packaging is directly built on top of version control systems.
This means for example that \href{https://github.com/xamino/tox-dynboot}{github.com/xamino/tox-dynboot} is both the package path and the URL where the package can be retrieved from.
Within the code the package would be referenced by the name, commonly the last part of the package path.
Golang also requires all code to be formatted according to its specifications which results in improved readability across different packages.
A variety of tools are directly built into the development suite, including a tool to fetch packages from their path and a tool for vetting and formatting Golang code.

\subsection{Tox Binding}
\label{sub:Tox Binding}

As stated in various instances before we will be building all peer to peer communication on the Tox core library~\cite{web:site:github:toxcore}.
Since the library is implemented with the C programming language we require a Golang wrapper for it.
Instead of implementing one ourselves which would have cost us a large amount of development time we chose to use an existing one.
With some research we chose the wrapper written and provided by codedust via Github~\cite{web:site:github:gotox}.

At the start of the Tinzenite implementation this wrapper still lacked one significant feature that Tinzenite required, namely the capability of sending and receiving files.
However a feature request~\cite{web:site:github:file_issue} was submitted and promptly implemented by the maintainer.
The maintainer was also forthcoming in helping us solve bugs and problems with our usage of the wrapper for which we are grateful.

\subsection{JSON}
\label{sub:JSON}

Since the underlying Tox channel is initially text based we propose to implement all peer to peer communication as a human readable messaging format.
We will therefore utilize Javascript object notation, short JSON, as a machine readable message format while retaining easy readability for developers.
As an added bonus Golang has high level support for converting language structures into and from JSON.

\section{Tinzenite Library}

TODO: on the topic of salted hashes: note where the salt is stored etc.

%TODO
TODO: on receiving an update: queue in connection specific command queue (one per connection because only one OP per connection) (update / redo existing fetch if applicable != FIFO); fetch first file in queue.
Then wait a bit (?) before propagating update yourself (decouple receive and send time frames?). <-- Isn't this implementation details?

TODO: add capability for delta updates... if possible. :P
Delta is difficult because we must effectively track parts of files instead of complete files... how to do this?
use librsync! <-- Really good and easy to use, will save a ton of work!

TODO: Also remember that multiple file transfers might be a problem.
Do we limit the connection to one transfer at a time or can we fetch everything at once?

TODO: I need to put some thought into avoiding a conflict between the disk watcher and when Tinzenite updates the objects... :P

TODO: Another feature that might be viable to implemented as an advanced feature is the capability of easily comparing peer IDs via pretty hashes or so.
Since these would be required to be the same on both ends these should probably also be supported by the core library.

TODO: the library should accept a path as a context.
Thus the quick switching between multiple directories can allow the single library to serve multiple directories.
In the case of the server n libraries can thus be mapped to m directories.
Should make sure that we can support encrypted and trusted peers side by side too (depending on whether the directory is clear or not).

TODO: The initial version of the Tinzenite trusted peer only used file hashes to check for modifications.
For large files or a large amount of files this proved to be a very slow operation.
Thus we also locally store the modification time as written to the file system upon creation and modification of a file.
As long as this modtime did not change we do not need to recalculate the hash as nothing has changed since the last check.
Thus Tinzenite only needs to recalculate the hash when the file was in some way modified.
This greatly speeds up the update detection phase.

\section{Trusted Peer}

TODO

\section{Encrypted Peer}

TODO

\section{Encryption}
\label{sec:Encryption}

This section will discuss the scheme used to encrypt and decrypt files within Tinzenite and how the keys are stored and shared.
Generally speaking Tinzenite uses to layers to ensure security.
The encryption scheme we used in Tinzenite is the NaCl library~\cite{bernstein2012security} through its interoperable Golang package~\cite{web:site:golang:box}.% interoperable is spelled correctly
From this package we utilize just three methods: \textit{"GenerateKey"}, \textit{"Open"}, and \textit{"Seal"}.
Respectively they are used to generate encryption keys, decrypt data, and encrypt data.

\subsection{File Encryption}
\label{sub:File Encryption}

Every Tinzenite network generates a single permanent key pair which is used to encrypt and decrypt data.
Each peer upon creation generates these keys but will overwrite them with the network's keys if connected to an existing network during bootstrapping.
File data is encrypted before sending it and decrypted after receiving it when exchanging data with encrypted peers.

To encrypt and decrypt data via NaCl we require an associated nonce which must be atomic but unique to every encryption decryption cycle.
Thus we require a way to store and retrieve the nonce for each encrypted data blob.
Instead of writing the nonce somewhere else we opted to prepend the nonce to the encrypted data. % prepend is spelled correctly
Thus the first 24 bytes of every encrypted file contain the nonce required to decrypt it again.
It is important to note that the nonce is not part of the encrypted data and must be trimmed away before attempting to decrypt.

%TODO: add example diagramm: hello world * [nonce] * keys ==> nonce + encrypted ==> nonce:encrypted ==> nonce + encrypted ==> encrypted * [nonce] * keys ==> hello world
TODO: add diagram / image of this because I can :D

\subsection{Key Encryption}
\label{sub:Key Encryption}

TODO: describe seeding PRNG and how the keys are retrieved.
Also note that password can be changed without having to re-encrypt all encrypted data!

\subsection{Challenge Response}
\label{sub:Challenge Response}

The challenge response we use in Tinzenite is built on a very simple challenge.
For each challenge we generate a random number and locally store it, then encrypt it with the data encryption keys and send it to the other peer.
This responding peer decrypts the message and retrieves the number.
It then increments it by one, encrypts its answer, and sends it back.
If the received number is one value higher than the stored number, the challenge response is valid.

The challenging peer can thus be satisfied that the other peer is valid because it proved that it could validly decrypt and encrypt the correct values.
The responding peer knows the challenging peer is authenticated because it could issue a valid challenge for the network data encryption keys.
In all the challenge response mechanism for Tinzenite requires only two messages and a single random number to validate both sides of the exchange.
