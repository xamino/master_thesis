\chapter{Implementation}
\label{chap:implementation}

%TODO continue here
TODO: continue here (maybe start with the encryption stuff way down there...)

%TODO a whole lot
TODO: a whole lot.

\section{Tools and Environment}

TODO

\subsection{Tox}
\label{sub:Tox}

I think I will be using this binding for Tox: \url{https://github.com/codedust/go-tox}.
Note: not sure if he has implemented file transfers yet, which I definitely require!
Although I can get started without them for validating the protocol.

\section{Dependencies}
\label{sec:Dependencies}

This section briefly highlights the technologies we chose to support our work.
These range from software solutions to data organization standards.
Here we will concentrate on the broad features we require for Tinzenite and how they may impact our work.
For our experiences and how exactly we used them see chapter~\ref{chap:implementation} where we go into the specifics of the implementation of Tinzenite.

\subsection{Tox}

A core aspect of this thesis is implementing the system using the peer to peer encrypted communication channel provided by the Tox communication suite~\cite{web:site:tox}.
Initially developed as a Skype replacement the underlying transport layer was also intended to be usable for alternative services.
We will make use of this and let Tox handle most of the communication aspects.

Unlike many other communication applications, Tox does not require the creation of an account online.
A user can create as many Tox identities as desired.
Each identity consists of a public and private key where the public key is the identity of the user~\cite{web:site:tox:crypto}.
Tox identities are dynamically mapped to the user's current internet address whenever the users are online via a distributed hash table.
Once two users are online at the same time (off line messaging is still being implemented at this time) and have added each other as friends (which stores the other's Tox identity for future usage) they can establish a communication channel.
The Tox messaging clients use the channel to facilitate text, audio, and video chats, with support for file transfers.
All data is encrypted with perfect forward secrecy and sent directly from one client to the other\footnote{Although TCP relay tunneling is sometimes used to punch through obstructions.}.

Tinzenite will build on the peer to peer, distributed, and encrypted communication channel provided.
In our case each directory on each peer will be its own Tox identity.
Every directory that is synchronized between multiple devices has its own network of friends which consists of the group of authorized peers.
For the setup Tinzenite will require the user to allow the initial connection to any single other peer.
The friend list is then synchronized by Tinzenite between all peers automatically.

Since Tox itself is written in C and we intend to use Golang we require a binding for the Tox core.
We intend to use an existing binding - specifically this one \cite{web:site:tox:golang} - to allow us to concentrate on the core aspects of our thesis.

\subsection{Golang}

Our implementation language of choice is Golang, usually referred to by the shorthand Go~\cite{web:site:golang}.
The language is new to the author of this thesis but will hopefully provide to be an interesting intellectual challenge.
Since the main language at Ulm University is mostly Java for student work, this thesis will hopefully also offer some insight into the differences between the two.

Golang was created at Google in 2007, announced and open sourced in 2009.
The reason for yet another language is given in the language's frequently asked questions page as: "Go is an attempt to combine the ease of programming of an interpreted, dynamically typed language with the efficiency and safety of a statically typed, compiled language. It also aims to be modern, with support for networked and multicore computing. Finally, it is intended to be fast: it should take at most a few seconds to build a large executable on a single computer."~\cite{web:site:golang:faq}.
Since Tinzenite is a networked system and offers many possible applications for using concurrent operations it was deemed a good match for this thesis.

Golang, much like Java, comes with a wide range of available default packages to use directly within a program.
Beyond the basics we will make use of the provided cypher package to implement all encryption related tasks where required.

\subsection{Hadoop}

As the encrypted server peer is intended to run as a service for multiple parallel different Tinzenite peers of multiple users it will require some extra work into how to store the expected large size of the data.
We will therefore look into using Hadoop~\cite{web:site:hadoop} for data storage.
This will allow third parties to run a single instance of the server peer even for many users at once while being able to reliably service all data.

%TODO
TODO: Need to rewrite / add to this once I've actually used Hadoop.
Currently I'm somewhat uninformed on the exact consequences of using this for the server peer.

\subsection{JSON}
\label{sub:JSON}

Since the underlying Tox channel is initially text based we propose to implement all peer to peer communication as a human readable messaging format.
We will therefore utilize Javascript object notation, short JSON, as a machine readable message format while retaining easy readability for developers.
As an added bonus Golang has high level support for converting language structures into and from JSON.

\subsection{Librsync}

The feature of delta updates is again not a trivial matter and we thus turn to existing solutions to shorten our work load in this regard.
We intend to utilize librsync~\cite{web:site:librsync} for the implementation of the specifics.

The librsync library is similar to the rsync and xdelta programs.
Unlike the two however librsync does not require the file in both before and after state to create a delta.
Requiring both versions of the file would immediately remove any benefit of using file deltas in our case as we would be required to send the file completely anyway.
Librsync avoids this by only sending a signature of the original version of the file which consists of block-wise hashes of the contents.
By comparing the new version block for block it can then determine which blocks have been changed and send only the corresponding data.

The library is again written in C, therefore requiring a binding for us to be able to directly use its functionality.
We found and plan to use the binding offered at \cite{web:site:librsync:golang}.

\section{Tinzenite Library}

TODO: on the topic of salted hashes: note where the salt is stored etc.

%TODO
TODO: on receiving an update: queue in connection specific command queue (one per connection because only one OP per connection) (update / redo existing fetch if applicable != FIFO); fetch first file in queue.
Then wait a bit (?) before propagating update yourself (decouple receive and send time frames?). <-- Isn't this implementation details?

TODO: add capability for delta updates... if possible. :P
Delta is difficult because we must effectively track parts of files instead of complete files... how to do this?
use librsync! <-- Really good and easy to use, will save a ton of work!

TODO: Also remember that multiple file transfers might be a problem.
Do we limit the connection to one transfer at a time or can we fetch everything at once?

TODO: I need to put some thought into avoiding a conflict between the disk watcher and when Tinzenite updates the objects... :P

TODO: Another feature that might be viable to implemented as an advanced feature is the capability of easily comparing peer IDs via pretty hashes or so.
Since these would be required to be the same on both ends these should probably also be supported by the core library.

TODO: the library should accept a path as a context.
Thus the quick switching between multiple directories can allow the single library to serve multiple directories.
In the case of the server n libraries can thus be mapped to m directories.
Should make sure that we can support encrypted and trusted peers side by side too (depending on whether the directory is clear or not).

\section{Trusted Peer}

TODO

\section{Encrypted Peer}

TODO

\section{Encryption}
\label{sec:Encryption}

This section will discuss the scheme used to encrypt and decrypt files within Tinzenite and how the keys are stored and shared.
Generally speaking Tinzenite uses to layers to ensure security.
The encryption scheme we used in Tinzenite is the NaCl library~\cite{bernstein2012security} through its interoperable Golang package~\cite{web:site:golang:box}.% interoperable is spelled correctly
From this package we utilize just three methods: \textit{"GenerateKey"}, \textit{"Open"}, and \textit{"Seal"}.
Respectively they are used to generate encryption keys, decrypt data, and encrypt data.

\subsection{File Encryption}
\label{sub:File Encryption}

Every Tinzenite network generates a single permanent key pair which is used to encrypt and decrypt data.
Each peer upon creation generates these keys but will overwrite them with the network's keys if connected to an existing network during bootstrapping.
File data is encrypted before sending it and decrypted after receiving it when exchanging data with encrypted peers.

To encrypt and decrypt data via NaCl we require an associated nonce which must be atomic but unique to every encryption decryption cycle.
Thus we require a way to store and retrieve the nonce for each encrypted data blob.
Instead of writing the nonce somewhere else we opted to prepend the nonce to the encrypted data. % prepend is spelled correctly
Thus the first 24 bytes of every encrypted file contain the nonce required to decrypt it again.
It is important to note that the nonce is not part of the encrypted data and must be trimmed away before trying to decrypt.

%TODO: add example diagramm: hello world * [nonce] * keys ==> nonce + encrypted ==> nonce:encrypted ==> nonce + encrypted ==> encrypted * [nonce] * keys ==> hello world
TODO: add diagram / image of this because I can :D

\subsection{Key Encryption}
\label{sub:Key Encryption}

TODO: describe seeding PRNG and how the keys are retrieved.
Also note that password can be changed without having to re-encrypt all encrypted data!

\subsection{Challenge Response}
\label{sub:Challenge Response}

The challenge response we use in Tinzenite is built on a very simple challenge.
For each challenge we generate a random number and locally store it, then encrypt it with the data encryption keys and send it to the other peer.
This responding peer decrypts the message and retrieves the number.
It then increments it by one, encrypts its answer, and sends it back.
If the received number is one value higher than the stored number, the challenge response is valid.

The challenging peer can thus be satisfied that the other peer is valid because it proved that it could validly decrypt and encrypt the correct values.
The responding peer knows the challenging peer is authenticated because it could issue a valid challenge for the network data encryption keys.
In all the challenge response mechanism for Tinzenite requires only two messages and a single random number to validate both sides of the exchange.
