\chapter{Implementation}
\label{chap:Implementation}

%TODO continue here
TODO: continue here (maybe start with the encryption stuff way down there...)

\section{Tools and Environment}
\label{sec:Tools and Environment}

In this section we will discuss the tools we used to build the software proof of concept.
This includes libraries we utilized and the software used to write the programs.

\subsection{Tox Binding}
\label{sub:Tox Binding}

I think I will be using this binding for Tox: \url{https://github.com/codedust/go-tox}.
Note: not sure if he has implemented file transfers yet, which I definitely require!
Although I can get started without them for validating the protocol.

Since Tox itself is written in C and we intend to use Golang we require a binding for the Tox core.
We intend to use an existing binding - specifically this one \cite{web:site:tox:golang} - to allow us to concentrate on the core aspects of our thesis.

\subsection{JSON}
\label{sub:JSON}

Since the underlying Tox channel is initially text based we propose to implement all peer to peer communication as a human readable messaging format.
We will therefore utilize Javascript object notation, short JSON, as a machine readable message format while retaining easy readability for developers.
As an added bonus Golang has high level support for converting language structures into and from JSON.

\subsection{Librsync}

TODO: this is future work

The feature of delta updates is again not a trivial matter and we thus turn to existing solutions to shorten our work load in this regard.
We intend to utilize librsync~\cite{web:site:librsync} for the implementation of the specifics.

The librsync library is similar to the rsync and xdelta programs.
Unlike the two however librsync does not require the file in both before and after state to create a delta.
Requiring both versions of the file would immediately remove any benefit of using file deltas in our case as we would be required to send the file completely anyway.
Librsync avoids this by only sending a signature of the original version of the file which consists of block-wise hashes of the contents.
By comparing the new version block for block it can then determine which blocks have been changed and send only the corresponding data.

The library is again written in C, therefore requiring a binding for us to be able to directly use its functionality.
We found and plan to use the binding offered at \cite{web:site:librsync:golang}.

\section{Tinzenite Library}

TODO: on the topic of salted hashes: note where the salt is stored etc.

%TODO
TODO: on receiving an update: queue in connection specific command queue (one per connection because only one OP per connection) (update / redo existing fetch if applicable != FIFO); fetch first file in queue.
Then wait a bit (?) before propagating update yourself (decouple receive and send time frames?). <-- Isn't this implementation details?

TODO: add capability for delta updates... if possible. :P
Delta is difficult because we must effectively track parts of files instead of complete files... how to do this?
use librsync! <-- Really good and easy to use, will save a ton of work!

TODO: Also remember that multiple file transfers might be a problem.
Do we limit the connection to one transfer at a time or can we fetch everything at once?

TODO: I need to put some thought into avoiding a conflict between the disk watcher and when Tinzenite updates the objects... :P

TODO: Another feature that might be viable to implemented as an advanced feature is the capability of easily comparing peer IDs via pretty hashes or so.
Since these would be required to be the same on both ends these should probably also be supported by the core library.

TODO: the library should accept a path as a context.
Thus the quick switching between multiple directories can allow the single library to serve multiple directories.
In the case of the server n libraries can thus be mapped to m directories.
Should make sure that we can support encrypted and trusted peers side by side too (depending on whether the directory is clear or not).

TODO: The initial version of the Tinzenite trusted peer only used file hashes to check for modifications.
For large files or a large amount of files this proved to be a very slow operation.
Thus we also locally store the modification time as written to the file system upon creation and modification of a file.
As long as this modtime did not change we do not need to recalculate the hash as nothing has changed since the last check.
Thus Tinzenite only needs to recalculate the hash when the file was in some way modified.
This greatly speeds up the update detection phase.

\section{Trusted Peer}

TODO

\section{Encrypted Peer}

TODO

\section{Encryption}
\label{sec:Encryption}

This section will discuss the scheme used to encrypt and decrypt files within Tinzenite and how the keys are stored and shared.
Generally speaking Tinzenite uses to layers to ensure security.
The encryption scheme we used in Tinzenite is the NaCl library~\cite{bernstein2012security} through its interoperable Golang package~\cite{web:site:golang:box}.% interoperable is spelled correctly
From this package we utilize just three methods: \textit{"GenerateKey"}, \textit{"Open"}, and \textit{"Seal"}.
Respectively they are used to generate encryption keys, decrypt data, and encrypt data.

\subsection{File Encryption}
\label{sub:File Encryption}

Every Tinzenite network generates a single permanent key pair which is used to encrypt and decrypt data.
Each peer upon creation generates these keys but will overwrite them with the network's keys if connected to an existing network during bootstrapping.
File data is encrypted before sending it and decrypted after receiving it when exchanging data with encrypted peers.

To encrypt and decrypt data via NaCl we require an associated nonce which must be atomic but unique to every encryption decryption cycle.
Thus we require a way to store and retrieve the nonce for each encrypted data blob.
Instead of writing the nonce somewhere else we opted to prepend the nonce to the encrypted data. % prepend is spelled correctly
Thus the first 24 bytes of every encrypted file contain the nonce required to decrypt it again.
It is important to note that the nonce is not part of the encrypted data and must be trimmed away before trying to decrypt.

%TODO: add example diagramm: hello world * [nonce] * keys ==> nonce + encrypted ==> nonce:encrypted ==> nonce + encrypted ==> encrypted * [nonce] * keys ==> hello world
TODO: add diagram / image of this because I can :D

\subsection{Key Encryption}
\label{sub:Key Encryption}

TODO: describe seeding PRNG and how the keys are retrieved.
Also note that password can be changed without having to re-encrypt all encrypted data!

\subsection{Challenge Response}
\label{sub:Challenge Response}

The challenge response we use in Tinzenite is built on a very simple challenge.
For each challenge we generate a random number and locally store it, then encrypt it with the data encryption keys and send it to the other peer.
This responding peer decrypts the message and retrieves the number.
It then increments it by one, encrypts its answer, and sends it back.
If the received number is one value higher than the stored number, the challenge response is valid.

The challenging peer can thus be satisfied that the other peer is valid because it proved that it could validly decrypt and encrypt the correct values.
The responding peer knows the challenging peer is authenticated because it could issue a valid challenge for the network data encryption keys.
In all the challenge response mechanism for Tinzenite requires only two messages and a single random number to validate both sides of the exchange.
