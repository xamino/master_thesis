\chapter{Implementation}
\label{chap:Implementation}

In this chapter we will expand on the process of implementing our proof of concept.
Before we can discuss the actual work of implementing the architecture we need to define the developing environment.
This will include an introduction of the software libraries we will base some functionality of Tinzenite on.

\section{Tools and Environment}
\label{sec:Tools and Environment}

In this section we will discuss the tools we used to build the software proof of concept.
This includes libraries we utilized and the software used to write the programs.

\subsection{Golang}
\label{sub:Golang}

As previously stated the proof of concept implementation will be developed using the programming language Golang.
We will make full use of a range of features which we will briefly highlight in the following.

A Golang program will compile into a single native executable file, with statically linked dependencies.
Cross compilation is available to all major operating systems and processor architectures.
Unlike for example Java Golang does not depend on a virtual machine to run resulting in performance that is near to natively compiled C code.
Furthermore Golang is not an object oriented language and based more on C than any other language.
Golang is statically typed and garbage collected.
This gives us type safety and removes the need to manage the memory ourselves\footnote{Mostly. Care has to be taken to avoid needlessly creating some objects as discussed in section~\ref{TODO}}.
For a developer coming from Java a large standard library helps to ease the transition: Golang offers such a standard library.
We found writing Golang code to be less verbose than Java code for the same task while not being any harder to comprehend.

Different is the way errors are handled.
While in Java error handling is done via exceptions, Golang uses return values to signal errors.
This poses less of a problem than it may initially seem to as Golang functions can return multiple values.
Furthermore Golang exposes and allows working with object pointers.
Concurrency is also directly built into the language via so called \textit{"go routines"} and channels.
Unlike Java which builds objects with class inheritance, Golang uses composition and interfaces to build objects.
Building on this Golang does not even require the declaration of which interfaces an object implements -- having the method of an interface means that that object implements the interface.

Golang also lacks a few features, notably generics and function overloading.
We found these to be relatively trivial to work around, although the lack of generics leads to an increase in redundant boilerplate code.
A possibly higher hurdle is the lack of fine granular permissions: unlike Java Golang knows only private and public variables and functions, indicated by their names beginning with respectively a lowercase or uppercase letter.

As to the development environment surrounding Golang only a few specifics should be noted.
A very nice feature is that packaging is directly built on top of version control systems.
This means for example that \textit{"\href{https://github.com/xamino/tox-dynboot}{github.com/xamino/tox-dynboot}"} is both the package path and the URL where the package can be retrieved from.
Within the code the package would be referenced by the name, commonly the last part of the package path.
Golang also requires all code to be formatted according to its specifications which results in improved readability across different packages.
A variety of tools are directly built into the development suite, including a tool to fetch packages from their path and a tool for vetting and formatting Golang code.

\subsection{JSON}
\label{sub:JSON}

\begin{figure}[htp]
    \begin{lstlisting}[language=golang,firstnumber=0]
    type Message struct {
        Address string
        Subject string `json:"omitempty"`
        Content string `json:"Message"`
        read    bool
    }
    \end{lstlisting}
    \begin{lstlisting}[language=json,firstnumber=0]
    {
        "Address":"192.168.178.100",
        "Message":"Log in successful!"
    }
    \end{lstlisting}
\caption[Golang JSON Example]{
    An example Golang struct with tags and its corresponding JSON representation.
    Note that \textit{"Subject"} is missing from the JSON due to the \textit{"omitempty"} tag and \textit{"read"} due to it being private.
    Also note that \textit{"Content"} has been renamed to \textit{"Message"}.
}
\label{golang:json_example}
\end{figure}

Since the underlying Tox channel is built for text based messaging we propose to implement all peer to peer communication as a human readable messaging format.
We will therefore utilize Javascript object notation, short JSON, as a machine readable message format while retaining easy readability for developers.
As an added bonus Golang has support for converting objects by default thanks to the standard libraries.
The generation of JSON can be fine tuned by utilizing in-language tagging.
Figure~\ref{golang:json_example} shows a very simple example.

\subsection{Tox Binding}
\label{sub:Tox Binding}

As stated in various instances before we will be building all peer to peer communication on the Tox core library~\cite{web:site:github:toxcore}.
Since the library is implemented with the C programming language we require a Golang wrapper for it.
Instead of implementing one ourselves which would have cost us a large amount of development time we chose to use an existing one.
With some research we chose the wrapper written and provided by codedust via Github~\cite{web:site:github:gotox}.

At the start of the Tinzenite implementation this wrapper still lacked one significant feature that Tinzenite required, namely the capability of sending and receiving files.
However a feature request~\cite{web:site:github:file_issue} was submitted and promptly implemented by the maintainer.
The maintainer was also forthcoming in helping us solve bugs and problems with our usage of the wrapper for which we are grateful.

\subsection{Hadoop Client Binding}
\label{sub:Hadoop Client Binding}

For the encrypted peer we required an implementation for a client for the Hadoop distributed file system.
We chose the implementation by the Github user colinmarc.
Notably we used the branch that adds write support~\cite{web:site:github:hdfs}.
This library is not a wrapper but an implementation of a HDFS client written in Golang.

\subsection{Environment}
\label{sub:Environment}

Tinzenite was implemented on the Arch Linux distribution Antergos~\cite{web:site:antergos}, specifically the amd64 flavor.
The Golang environment was set up using the corresponding Arch package~\cite{web:site:arch_go}.
We used the Golang tools provided by the package to compile our work.
The code itself was written using the Atom text editor~\cite{web:site:atom} with a variety of extensions, most notably the support extensions for Golang.
Git~\cite{web:site:git} was used for the version control system, with a hosted repository on Github here~\cite{web:site:github:tinzenite}.

\section{Software Structure}
\label{sec:Software Structure}

Tinzenite was developed not as a single package but as a package collection that each covers some parts of the complete scope.
In this section we will discuss the general layout of the packages and how they depend on one another.
All packages have their own repository on Github~\cite{web:site:github:tinzenite}.

\begin{description}[leftmargin=6em,style=nextline,noitemsep,nolistsep]
    \item[bootstrap]
        Contains the library for bootstrapping both encrypted and trusted peers to an existing Tinzenite network.
    \item[channel]
        Building on the Tox wrapper implements an abstract object for all Tox related communication code.
    \item[core]
        Implements the functionality for a trusted peer.
    \item[encrypted]
        Implements the functionality for an encrypted peer.
    \item[model]
        Contains the directory tracking code which manages a Tinzenite directory.
    \item[server]
        Built on the \emph{encrypted} package implements an example server program for an encrypted peer.
    \item[shared]
        Contains various shared objects used by multiple packages.
    \item[tin]
        Built on the \emph{core} package implements an example user program for a trusted peer.
\end{description}

The implementation started with the implementation of the \emph{model} and the \emph{channel} packages, then built the \emph{core} package on these.
At one point we began putting shared code into the \emph{shared} package, thus allowing it to grow as the implementation grew.
The \emph{tin} package was quickly added for testing and debugging purposes and grew alongside the trusted peer development.
Once the basic functions worked we implemented the \emph{bootstrap} package since we required multiple peers to continue working.
Finally we built the \emph{encrypted} and \emph{server} packages to implement the encrypted peer.
This in turn required some modifications to the \emph{bootstrap} package to enable it to bootstrap both trusted and encrypted peers.

\section{Highlights}
\label{sec:Highlights}

The following section will serve to discuss highlights of the implementation.
We will also expand on some aspects of the implemented functionality where we believe an expanded discussion is stimulating.

\subsection{Model}
\label{sub:Model}

The \emph{model} package contains the model object used by the trusted peer to manage a tracked directory.
Instances of the model can be created either by loading it from a JSON store or creating a new one.
The model itself does not actively update itself if the underlying directory changes: instead an update must be triggered by the utilizing code.
This allows the model to avoid having to employ file watchers.
It thus falls to the utilizing code to call the update method in regular intervals to ensure that the model remains up to date.

The initial version of the model object only used file hashes to check for modifications, according to the Tinzenite specifications.
For large files or a large amount of files this proved to be a very slow operation.
Thus we also store the modification time as written to the file system upon creation and modification of a file to the model.
This attribute is private to the model.
As long as the modification time did not change we do not need to recalculate the hash as nothing has changed since the last check.
Thus the model only needs to recalculate the hash when the file was actually modified.
This greatly speeds up the update detection phase.

Apart from reacting to direct directory changes the model object also allows remote updates to be applied.
Before a remote update can be applied a number of parameters must be checked however -- therefore the model object offers a \texttt{CheckMessage} method that returns whether the update must be truly applied.
The update may be ignored for example if it has already been applied, or when it concerns an already completed removal as stated in section~\ref{subs:Remove}.
Any call to \texttt{ApplyUpdateMessage} should be preceded by applying this message check.
Note that we have moved most of the removal logic code to its own code file for easier comprehension.

Any application of an update may trigger a merge conflict.
This is signaled by the model via an error.
It is up to the caller to then handle the merge in a valid fashion, likely calling the model to apply resulting updates to the directory.
Tinzenite handles merge conflicts as part of the \emph{core} package.

The \emph{model} package also implements the matcher object.
This object checks each directory for a \textit{".tinignore"} file and if it exists applies it to any model work on the directory.

\subsection{Channel}
\label{sub:Channel}

The \emph{channel} package wraps the Tox wrapper into the channel object which all communication is sent via.
The channel object makes use of callbacks to allow callers to react to incoming messages, file transfers, and other events.

Since the underlying Tox instance must be called in regular intervals, the channel object implements a background go routine that keeps Tox ticking.
To avoid locking up the Tox instance on callbacks, each callback is called asynchronously.
If a callback can result in a direct response that must be passed to the Tox instance another method is available.

Tox requires bootstrapping to known nodes to connect to the Tox network.
This bootstrapping is different from the bootstrapping of peers we will discuss later.
The channel object makes sure that the Tox instance is bootstrapped to the Tox network if it is not connected as long as the channel is kept running.
We dynamically retrieve a list of available Tox nodes using a specially written package~\cite{web:site:github:tox-dynboot}.
This list is used to try to connect a given channel to the Tox network.

Unlike both the Tox instance and the Golang wrapper for it, the channel object wraps the file transmission nicely.
If a file transfer request is received it asks the utilizing code via a callback whether to accept the transfer or not.
If accepted it will again notify when the file has been successfully received or the transfer failed.
Tox itself handles file transfers in data blocks.
For our purposes the abstraction of this process greatly simplifies quite a lot of code that builds on file transfers.

The channel object furthermore offers a wide range of helpful methods that are not directly available from a Tox instance.
This includes handling all addresses as hexadecimal encoded strings versus byte arrays and a number of status functions.

\subsection{Tin Program}
\label{sub:Tin Program}

The \emph{tin} package is an example implementation of a trusted peer built on the \emph{core} package.
While a true client built on a stable Tinzenite version should interface with the user via a graphical user interface, we forewent this because of the increased development time.
Thus the Tin program is a simple command line interface based program.

It offers up a range of flags to make managing a Tinzenite directory easier.
Each instance of Tin should run for a single trusted Tinzenite peer.
Additionally the program can also be used to create new peers and bootstrap them to the Tinzenite network.
In the case of bootstrapping an encrypted peer the program will exit on successful completion.
For trusted peers it will immediately go over into running the directory.
If a trusted peer receives a bootstrapping request it asks the user to validate the given peer address and requested trust level.

The program also automatically updates the local directory, requests remote updates, and synchronizes with available encrypted peers at certain intervals.
This servers to prove that Tinzenite can run completely without user input.
In fact apart from setting up a peer the synchronization runs fully without user input, even if merge conflicts arise.
Care was furthermore taken to ensure that the entire program could run using as little resources as possible.
Currently the program runs with negligible CPU and RAM usage even though synchronizing regularly.
The only truly expensive operation where the program requires more performance is for hash generation and encryption when handling files.

The \emph{core} package itself wraps the complete trusted peer code.
Basically it uses the model object and the channel object to offer all trusted peer functionality.
Notably it also implements how Tinzenite handles merge conflicts.
For software written against it the core package exposes a Tinzenite object with which the trusted peer can be controlled.

\subsection{Bootstrap}
\label{sub:Bootstrap}

Initially we planned to include the bootstrapping code directly within the tin and core packages.
However the differences in how a peer must react to incoming messages and transfers would have greatly increased the already substantial code complexity of these packages.
Therefore we moved all bootstrapping related code into its own package.
This has the large advantage that programs can easily implement just bootstrapping if required without requiring any further package imports.

The basic function of bootstrapping is relatively simple.
It requires the address of the trusted peer to connect to and sends a Tox friend request to it to initiate the connection.
Once the friend request has been accepted and the trusted peer has been connected the actual bootstrapping takes place.
For a new trusted peer that includes fetching the complete current state of the directory.
Once the transfers are complete the bootstrapping code finishes and the directory can now be started as a normal trusted peer.

The bootstrap package was mainly implemented in one sitting and serves as a proof of concept that the previously implemented code for the trusted peer program could be reused easily.
Apart from bug fixes we only had to update it once we implemented the encrypted peer functionality.

\subsection{Server Program}
\label{sub:Server Program}

Much like the Tin software the \emph{server} package provides an implementation for the \emph{encrypted} package.
It offers a command line interface program for creating and running an encrypted peer.

\begin{figure}[htp]
    \begin{lstlisting}[language=golang,firstnumber=0]
        package encrypted

        type Storage interface {
        	Store(key string, data []byte) error
        	Retrieve(key string) ([]byte, error)
        	Remove(key string) error
        }
    \end{lstlisting}
\caption[Encrypted Storage Interface]{The storage interface that the encrypted peer must implement to use the \emph{encrypted} package. Comments have been removed.}
\label{golang:storage_interface}
\end{figure}

Adding encrypted peers to Tinzenite required two tasks to be successful: the implementation of the encrypted peer and the extension of the trusted peer to be capable of utilizing it.
The first task of implementing the encrypted peer proved to be comparatively simple.
Basically all it has to do is manage its lock to any single trusted peer and, if locked, allow the fetching and retrieval of files.
Most files the encrypted peer handles are user data files.
One of the goals for this thesis was to support writing these files to the Hadoop distributed file system.
Therefore we implemented the encrypted peer so that all user files are written with a specified storage interface as seen in figure~\ref{golang:storage_interface}.
However this storage interface is not used for all files.
The authentication file and the peer files are required to exist unencrypted and required for the encrypted peer to run correctly.
Therefore these files are written to disk within the \textit{"org"} directory\footnote{The encrypted peer does not share the directory structure of a trusted peer. The reason for this is that an encrypted peer lacks many of the features that went into the design of the \textit{".tinzenite"} directory. Thus a simpler, flatter structure was chosen.}.

The storage interface allows encrypted clients, such as the \emph{server} package provides an example of, to interface with any storage interface the developer of a utilizing program wishes it to.
For this thesis we implemented two versions of the interface for the server program.
First for debugging and personal use we implemented a version of the interface that simply writes all data to disk, named as the key of the data.
Retrieval looks up the file by checking for the existence of a file named as the given key and returns the associated data.
Then we implemented the actual Hadoop capable version of the interface.
Our version of the interface creates a connection to a Hadoop distributed file system when initiating.
All further file accesses will then be handled as operations on the Hadoop cluster.

Once the encrypted peer was implemented we turned to the more complex task of integrating encrypted peers into the capabilities of the trusted peer.
This meant modifying the core package so that trusted peers could differentiate between trusted and encrypted peers and communicate with each accordingly.
Upon receiving a message the trusted peer always first checks whether the message came from an encrypted peer or a trusted peer on a case by case basis.
We do this by checking the address of the sender against the known peer list and ensuring that trusted peers have been authenticated.
The message is then passed on to the specific logic for the type of peer.

The logic for handling an encrypted peer comes down to a relatively simple process.
Upon successful locking an encrypted peer to itself, the trusted peer requests the encrypted model.
If the encrypted peer responds with a notification that the file doesn't exist the encrypted peer is considered empty and the logic skips to uploading the current state of the trusted peer.

If a model is received the trusted peer must first compare the remote model against its own model to check for changes.
Unknown updates that the encrypted peer has are applied to the trusted peer by fetching the necessary files.
Once this is complete the next step is to update the encrypted peer to the state of the trusted peer.
Updates that the trusted peer has but the encrypted peer lacks are uploaded and finally the current model encrypted and also uploaded.
Then the encrypted peer is unlocked so that other trusted peers can access it too.

\subsection{Golang Issues}
\label{sub:Golang Issues}

We encountered a small amount of gotchas due to our unfamiliarity with the Golang language.
In the interest of full disclosure we will use this section to briefly touch on these matters.

Tinzenite builds heavily on the standard libraries included with the language.
Since Golang is still a relatively new language we expected to encounter bugs and issues as we implemented Tinzenite.
However we only ever encountered a single bug.
It effected the generation of a random integer for issuing a challenge.
After creating a valid random \texttt{int64} value for the challenge we required a byte slice representation of the variable to encrypt it.
However we had to determine how large to make the byte slice so that the variable could be stored in it.
Research lead to us believe that utilizing the \texttt{byte.Size} method would allows us to make the byte slice just large enough to contain the random number.
But the method always returned incorrect values.
Our workaround is to simply create the slice large enough for all possible values at a small memory cost.

The good performance of Tinzenite was initially not the case.
First versions of the trusted peer had a slow memory and processing leak resulting in steadily rising CPU and RAM usage until the host computer killed the process after a few minutes.
We tracked this down to our usage of an endlessly running go routine utilizing time.Tick to run in intervals.
As stated in the method documentation the underlying Ticker can not be closed, thus resulting in a leak~\cite{web:site:golang:time:tick}.
We worked around this issue by simply reusing the timing objects instead of recreating new ones every interval.

Another issue we found ourselves with was that we had no way to determine the type of \texttt{struct} we required to parse incoming JSON messages.
Thus we implemented a \textit{"Type"} attribute for all messages which we use to determine the correct type of the message.
Golang's composition was not a viable way of solving this to our satisfaction as all message objects did not have any differing methods.
The correct way to do this is to parse the incoming messages to an empty interface which is valid for all types.
The type can then be checked against and the message cast.

\begin{figure}[htp]
    \begin{lstlisting}[language=golang,firstnumber=0]
type MsgType int

const (
	MsgNone MsgType = iota
	MsgUpdate
	MsgRequest
	MsgNotify
	MsgLock
	MsgPush
	MsgChallenge
)
    \end{lstlisting}
\caption[Golang Enum Example]{One of the enumerations we defined for Tinzenite. Note that for brevity we removed the comments.}
\label{golang:enum_example}
\end{figure}

For the defined messages that Tinzenite uses we heavily relied on enumerations for setting values.
Coming from Java we expected to find similar \texttt{enum} functionality in Golang.
This did not prove to be the case.
Golang lacks a specific implementation of enumerations but does allow for something similar using the \texttt{const} and \texttt{iota} keywords for specified variable types.
An example can be seen in figure~\ref{golang:enum_example}.
Our largest issue with this was that when converting these enumeration similes to JSON instead of the name of the enumeration the number value was output due to Golang seeing them as number value variables.
Thus instead of having JSON where each enumeration was easily interpretable we had values such as \texttt{"MsgType":1} where what we wanted was \texttt{"MsgType":"update"}.
The solution to this requires a lot of boilerplate code since Golang does not support generics at this point in time.
For each defined enumeration type we had to write custom \texttt{MarshalJSON} and \texttt{UnmarshalJSON} methods.

\section{Security}
\label{sec:Security}

%TODO continue here
TODO: Continue here.
Security stuff should probably be partially rewritten to tie into the rest of the implementation chapter.

This section will discuss the scheme used to encrypt and decrypt files within Tinzenite and how the keys are stored and shared.
Generally speaking Tinzenite uses to layers to ensure security.
The encryption scheme we used in Tinzenite is the NaCl library~\cite{bernstein2012security} through its interoperable Golang package~\cite{web:site:golang:box}.% interoperable is spelled correctly
From this package we utilize just three methods: \textit{"GenerateKey"}, \textit{"Open"}, and \textit{"Seal"}.
Respectively they are used to generate encryption keys, decrypt data, and encrypt data.

\subsection{File Encryption}
\label{sub:File Encryption}

Every Tinzenite network generates a single permanent key pair which is used to encrypt and decrypt data.
Each peer upon creation generates these keys but will overwrite them with the network's keys if connected to an existing network during bootstrapping.
File data is encrypted before sending it and decrypted after receiving it when exchanging data with encrypted peers.

To encrypt and decrypt data via NaCl we require an associated nonce which must be atomic but unique to every encryption decryption cycle.
Thus we require a way to store and retrieve the nonce for each encrypted data blob.
Instead of writing the nonce somewhere else we opted to prepend the nonce to the encrypted data. % prepend is spelled correctly
Thus the first 24 bytes of every encrypted file contain the nonce required to decrypt it again.
It is important to note that the nonce is not part of the encrypted data and must be trimmed away before attempting to decrypt.

%TODO: add example diagramm: hello world * [nonce] * keys ==> nonce + encrypted ==> nonce:encrypted ==> nonce + encrypted ==> encrypted * [nonce] * keys ==> hello world
TODO: add diagram / image of this because I can :D

\subsection{Key Encryption}
\label{sub:Key Encryption}

TODO: describe seeding PRNG and how the keys are retrieved.
Also note that password can be changed without having to re-encrypt all encrypted data!

\subsection{Challenge Response}
\label{sub:Challenge Response}

The challenge response we use in Tinzenite is built on a very simple challenge.
For each challenge we generate a random number and locally store it, then encrypt it with the data encryption keys and send it to the other peer.
This responding peer decrypts the message and retrieves the number.
It then increments it by one, encrypts its answer, and sends it back.
If the received number is one value higher than the stored number, the challenge response is valid.

The challenging peer can thus be satisfied that the other peer is valid because it proved that it could validly decrypt and encrypt the correct values.
The responding peer knows the challenging peer is authenticated because it could issue a valid challenge for the network data encryption keys.
In all the challenge response mechanism for Tinzenite requires only two messages and a single random number to validate both sides of the exchange.
