\chapter{Implementation}
\label{chap:Implementation}

In this chapter we will expand on the process of implementing our proof of concept.
Before we can discuss the actual work of implementing the architecture we need to define the developing environment.
This will include an introduction of the software libraries we will base some functionality of Tinzenite on.

\section{Tools and Environment}
\label{sec:Tools and Environment}

In this section we will discuss the tools we used to build the software proof of concept.
This includes libraries we utilized and the software used to write the programs.

\subsection{Golang}
\label{sub:Golang}

As previously stated the proof of concept implementation will be developed using the programming language Golang.
We will make full use of a range of features which we will briefly highlight in the following.

A Golang program will compile into a single native executable file.
Cross compilation is available to all major operating systems and processor architectures.
Unlike for example Java Golang does not depend on a virtual machine to run resulting in performance that is near to natively compiled C code.
Golang is statically typed and garbage collected.
This gives us type safety and removes the need to manage the memory ourselves\footnote{Mostly. Care has to be taken to avoid needlessly creating some objects as discussed in section~\ref{TODO}}.
For a developer coming from Java a large standard library helps to ease the transition: Golang offers such a standard library.
We found writing Golang code to be less verbose than Java code for the same task while not being any harder to comprehend.

Different is the way errors are handled.
While in Java error handling is done via exceptions, Golang uses return values to signal errors.
This poses less of a problem than it may initially seem to as Golang functions can return multiple values.
Furthermore Golang exposes and allows working with object pointers.
Concurrency is also directly built into the language via so called \textit{"go routines"} and channels.
Unlike Java which builds objects with class inheritance, Golang uses composition and interfaces to build objects.
Building on this Golang does not even require the declaration of which interfaces an object implements -- having the method of an interface means that that object implements the interface.

Golang also lacks a few features, notably generics and function overloading.
We found these to be relatively trivial to work around, although the lack of generics leads to an increase in redundant boilerplate code.
A possibly higher hurdle is the lack of fine granular permissions: unlike Java Golang knows only private and public variables and functions, indicated by their names beginning with respectively a lowercase or uppercase letter.

As to the development environment surrounding Golang only a few specifics should be noted.
A very nice feature is that packaging is directly built on top of version control systems.
This means for example that \textit{"\href{https://github.com/xamino/tox-dynboot}{github.com/xamino/tox-dynboot}"} is both the package path and the URL where the package can be retrieved from.
Within the code the package would be referenced by the name, commonly the last part of the package path.
Golang also requires all code to be formatted according to its specifications which results in improved readability across different packages.
A variety of tools are directly built into the development suite, including a tool to fetch packages from their path and a tool for vetting and formatting Golang code.

\subsection{JSON}
\label{sub:JSON}

\begin{figure}[htp]
    \begin{lstlisting}[language=golang,firstnumber=0]
    type Message struct {
        Address string
        Subject string `json:"omitempty"`
        Content string `json:"Message"`
        read    bool
    }
    \end{lstlisting}
    \begin{lstlisting}[language=json,firstnumber=0]
    {
        "Address":"192.168.178.100",
        "Message":"Log in successful!"
    }
    \end{lstlisting}
\caption[Golang JSON Example]{
    An example Golang struct with tags and its corresponding JSON representation.
    Note that \textit{"Subject"} is missing from the JSON due to the \textit{"omitempty"} tag and \textit{"read"} due to it being private.
    Also note that \textit{"Content"} has been renamed to \textit{"Message"}.
}
\label{golang:json_example}
\end{figure}

Since the underlying Tox channel is built for text based messaging we propose to implement all peer to peer communication as a human readable messaging format.
We will therefore utilize Javascript object notation, short JSON, as a machine readable message format while retaining easy readability for developers.
As an added bonus Golang has support for converting objects by default thanks to the standard libraries.
The generation of JSON can be fine tuned by utilizing in-language tagging.
Figure~\ref{golang:json_example} shows a very simple example.

\subsection{Tox Binding}
\label{sub:Tox Binding}

As stated in various instances before we will be building all peer to peer communication on the Tox core library~\cite{web:site:github:toxcore}.
Since the library is implemented with the C programming language we require a Golang wrapper for it.
Instead of implementing one ourselves which would have cost us a large amount of development time we chose to use an existing one.
With some research we chose the wrapper written and provided by codedust via Github~\cite{web:site:github:gotox}.

At the start of the Tinzenite implementation this wrapper still lacked one significant feature that Tinzenite required, namely the capability of sending and receiving files.
However a feature request~\cite{web:site:github:file_issue} was submitted and promptly implemented by the maintainer.
The maintainer was also forthcoming in helping us solve bugs and problems with our usage of the wrapper for which we are grateful.

\subsection{Hadoop Client Binding}
\label{sub:Hadoop Client Binding}

For the encrypted peer we required an implementation for a client for the Hadoop distributed file system.
We chose the implementation by the Github user colinmarc.
Notably we used the branch that adds write support~\cite{web:site:github:hdfs}.
This library is not a wrapper but an implementation of a HDFS client written in Golang.

\subsection{Environment}
\label{sub:Environment}

Tinzenite was implemented on the Arch Linux distribution Antergos~\cite{web:site:antergos}, specifically the amd64 flavor.
The Golang environment was set up using the corresponding Arch package~\cite{web:site:arch_go}.
We used the Golang tools provided by the package to compile our work.
The code itself was written using the Atom text editor~\cite{web:site:atom} with a variety of extensions, most notably the support extensions for Golang.
Git~\cite{web:site:git} was used for the version control system, with a hosted repository on Github here~\cite{web:site:github:tinzenite}.

\section{Software Structure}
\label{sec:Software Structure}

Tinzenite was developed not as a single package but as a package collection that each covers some parts of the complete scope.
In this section we will discuss the general layout of the packages and how they depend on one another.
All packages have their own repository on Github~\cite{web:site:github:tinzenite}.

\begin{description}[leftmargin=6em,style=nextline,noitemsep,nolistsep]
    \item[bootstrap]
        Contains the library for bootstrapping both encrypted and trusted peers to an existing Tinzenite network.
    \item[channel]
        Building on the Tox wrapper implements an abstract object for all Tox related communication code.
    \item[core]
        Implements the functionality for a trusted peer.
    \item[encrypted]
        Implements the functionality for an encrypted peer.
    \item[model]
        Contains the directory tracking code which manages a Tinzenite directory.
    \item[server]
        Built on the \emph{encrypted} package implements an example server program for an encrypted peer.
    \item[shared]
        Contains various shared objects used by multiple packages.
    \item[tin]
        Built on the \emph{core} package implements an example user program for a trusted peer.
\end{description}

The implementation started with the implementation of the \emph{model} and the \emph{channel} packages, then built the \emph{core} package on these.
At one point we began putting shared code into the \emph{shared} package, thus allowing it to grow as the implementation grew.
The \emph{tin} package was quickly added for testing and debugging purposes and grew alongside the trusted peer development.
Once the basic functions worked we implemented the \emph{bootstrap} package since we required multiple peers to continue working.
Finally we built the \emph{encrypted} and \emph{server} packages to implement the encrypted peer.
This in turn required some modifications to the \emph{bootstrap} package to enable it to bootstrap both trusted and encrypted peers.

\section{Highlights}
\label{sec:Highlights}

The following section will serve to discuss highlights of the implementation.
We will also expand on some aspects of the implemented functionality where we believe an expanded discussion is stimulating.

\subsection{Model}
\label{sub:Model}

The \emph{model} package contains the model object used by the trusted peer to manage a tracked directory.
Instances of the model can be created either by loading it from a JSON store or creating a new one.
The model itself does not actively update itself if the underlying directory changes: instead an update must be triggered by the utilizing code.
This allows the model to avoid having to employ file watchers.
It thus falls to the utilizing code to call the update method in regular intervals to ensure that the model remains up to date.

The initial version of the model object only used file hashes to check for modifications, according to the Tinzenite specifications.
For large files or a large amount of files this proved to be a very slow operation.
Thus we also store the modification time as written to the file system upon creation and modification of a file to the model.
This attribute is private to the model.
As long as the modification time did not change we do not need to recalculate the hash as nothing has changed since the last check.
Thus the model only needs to recalculate the hash when the file was actually modified.
This greatly speeds up the update detection phase.

Apart from reacting to direct directory changes the model object also allows remote updates to be applied.
Before a remote update can be applied a number of parameters must be checked however -- therefore the model object offers a \texttt{CheckMessage} method that returns whether the update must be truly applied.
The update may be ignored for example if it has already been applied, or when it concerns an already completed removal as stated in section~\ref{subs:Remove}.
Any call to \texttt{ApplyUpdateMessage} should be preceded by applying this message check.
Note that we have moved most of the removal logic code to its own code file for easier comprehension.

Any application of an update may trigger a merge conflict.
This is signaled by the model via an error.
It is up to the caller to then handle the merge in a valid fashion, likely calling the model to apply resulting updates to the directory.
Tinzenite handles merge conflicts as part of the \emph{core} package.

The \emph{model} package also implements the matcher object.
This object checks each directory for a \textit{".tinignore"} file and if it exists applies it to any model work on the directory.

\subsection{Channel}
\label{sub:Channel}

The \emph{channel} package wraps the Tox wrapper into the channel object which all communication is sent via.
The channel object makes use of callbacks to allow callers to react to incoming messages, file transfers, and other events.

Since the underlying Tox instance must be called in regular intervals, the channel object implements a background go routine that keeps Tox ticking.
To avoid locking up the Tox instance on callbacks, each callback is called asynchronously.
If a callback can result in a direct response that must be passed to the Tox instance another method is available.

Unlike both the Tox instance and the Golang wrapper for it, the channel object wraps the file transmission nicely.
If a file transfer request is received it asks the utilizing code via a callback whether to accept the transfer or not.
If accepted it will again notify when the file has been successfully received or the transfer failed.
Tox itself handles file transfers in data blocks.
For our purposes the abstraction of this process greatly simplifies quite a lot of code that builds on file transfers.

The channel object furthermore offers a wide range of helpful methods that are not directly available from a Tox instance.
This includes handling all addresses as hexadecimal encoded strings versus byte arrays and a number of status functions.

\subsection{Tin Program}
\label{sub:Tin Program}

The \emph{tin} package is an example implementation of a trusted peer built on the \emph{core} package.

TODO: model, channel, tin, bootstrap, server, security

%TODO continue here
TODO: Continue here

%TODO this stuff below should be worked into the text
\section{Tinzenite Library}

TODO: on the topic of salted hashes: note where the salt is stored etc.

%TODO
TODO: on receiving an update: queue in connection specific command queue (one per connection because only one OP per connection) (update / redo existing fetch if applicable != FIFO); fetch first file in queue.
Then wait a bit (?) before propagating update yourself (decouple receive and send time frames?). <-- Isn't this implementation details?

TODO: add capability for delta updates... if possible. :P
Delta is difficult because we must effectively track parts of files instead of complete files... how to do this?
use librsync! <-- Really good and easy to use, will save a ton of work!

TODO: Also remember that multiple file transfers might be a problem.
Do we limit the connection to one transfer at a time or can we fetch everything at once?

TODO: I need to put some thought into avoiding a conflict between the disk watcher and when Tinzenite updates the objects... :P

TODO: Another feature that might be viable to implemented as an advanced feature is the capability of easily comparing peer IDs via pretty hashes or so.
Since these would be required to be the same on both ends these should probably also be supported by the core library.

TODO: the library should accept a path as a context.
Thus the quick switching between multiple directories can allow the single library to serve multiple directories.
In the case of the server n libraries can thus be mapped to m directories.
Should make sure that we can support encrypted and trusted peers side by side too (depending on whether the directory is clear or not).

\section{Encryption}
\label{sec:Encryption}

This section will discuss the scheme used to encrypt and decrypt files within Tinzenite and how the keys are stored and shared.
Generally speaking Tinzenite uses to layers to ensure security.
The encryption scheme we used in Tinzenite is the NaCl library~\cite{bernstein2012security} through its interoperable Golang package~\cite{web:site:golang:box}.% interoperable is spelled correctly
From this package we utilize just three methods: \textit{"GenerateKey"}, \textit{"Open"}, and \textit{"Seal"}.
Respectively they are used to generate encryption keys, decrypt data, and encrypt data.

\subsection{File Encryption}
\label{sub:File Encryption}

Every Tinzenite network generates a single permanent key pair which is used to encrypt and decrypt data.
Each peer upon creation generates these keys but will overwrite them with the network's keys if connected to an existing network during bootstrapping.
File data is encrypted before sending it and decrypted after receiving it when exchanging data with encrypted peers.

To encrypt and decrypt data via NaCl we require an associated nonce which must be atomic but unique to every encryption decryption cycle.
Thus we require a way to store and retrieve the nonce for each encrypted data blob.
Instead of writing the nonce somewhere else we opted to prepend the nonce to the encrypted data. % prepend is spelled correctly
Thus the first 24 bytes of every encrypted file contain the nonce required to decrypt it again.
It is important to note that the nonce is not part of the encrypted data and must be trimmed away before attempting to decrypt.

%TODO: add example diagramm: hello world * [nonce] * keys ==> nonce + encrypted ==> nonce:encrypted ==> nonce + encrypted ==> encrypted * [nonce] * keys ==> hello world
TODO: add diagram / image of this because I can :D

\subsection{Key Encryption}
\label{sub:Key Encryption}

TODO: describe seeding PRNG and how the keys are retrieved.
Also note that password can be changed without having to re-encrypt all encrypted data!

\subsection{Challenge Response}
\label{sub:Challenge Response}

The challenge response we use in Tinzenite is built on a very simple challenge.
For each challenge we generate a random number and locally store it, then encrypt it with the data encryption keys and send it to the other peer.
This responding peer decrypts the message and retrieves the number.
It then increments it by one, encrypts its answer, and sends it back.
If the received number is one value higher than the stored number, the challenge response is valid.

The challenging peer can thus be satisfied that the other peer is valid because it proved that it could validly decrypt and encrypt the correct values.
The responding peer knows the challenging peer is authenticated because it could issue a valid challenge for the network data encryption keys.
In all the challenge response mechanism for Tinzenite requires only two messages and a single random number to validate both sides of the exchange.
