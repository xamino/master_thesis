\chapter{Concept}
\label{chap:concept}

%TODO a whole lot

\section{Basic Goals}

%TODO maybe move broad scope before features? But it builds on features... :P

\subsection{Features}

TODO: list features that I want to have.
These should come from and directly link to the existing software and their weaknesses and strengths.
The following is not yet the final list but should be a good start.
These features are system features, NOT single program features: these come below.

\begin{description}[leftmargin=2em,style=nextline,noitemsep,nolistsep]
\item[API]
    Design of an extensible API on which all communication between peers will be based.
    We will specifiy an API based on JSON encoded messages that will be sent as text messages via the Tox protocol.
\item[Peer to Peer Architecture]
    The complete software suite should run in a direct peer to peer mode to remove the requirement of third parties to facilitate data exchange and to remove the associated security risk.
    This includes the server client as it should be capable of exchanging data even with other server clients.
\item[Secure Transport]
    All communication between all clients should always be fully end to end encrypted.
\item[Client Encryption]
    Any client can be set to only retain an encrypted version of the data.
    In this case the keys for accessing said data are only stored between unencrypted clients.
\item[Server Client]
    A dedicated client for third party servers.
    Notable features are that a single instance should handle multiple users' accounts.
    Since large data amounts are to be expected, the server client will be capable of integrating the Hadoop distributed file system to directly support that.
\end{description}

TODO: Maybe I should also specifically list what Tinzenite won't be... ?
For example: what about the ability to publicly share something?
How can we support this without breaking security?

\subsection{Scope}

In this brief section we will go through the exact scope that this work is to fulfill.

\begin{description}[leftmargin=2em,style=nextline,noitemsep,nolistsep]
\item[MUST have]
    These features are required for the thesis to be considered basically successful.
    This means that the basic fundamentals of the proposed complete scope have been met and are in working order.
    Specifically this includes a fully working computer client based on a specified API on which all future work can be built on.
    This client must offer the basics required to get the system to work in a user friendly manner from setup through daily usage.
    Data transfer between multiple clients must work as expected with collision detection and correct version iteration upon updates.
\item[SHOULD have]
    Features in this category are features that built on the MUST have features and are thus not strictly required.
    In broad terms this includes two important aspects.
    First and foremost is the capability of having a client that only retains an encrypted version of the data.
    Built on this the second aspect is the server client that only ever retains an encrypted data set.
    The server also adds the capability of handling multiple users' data on a distributed file system capable of handling the large data size that are to be expected for multiple concurrent users.
    Further aspects that fall under the SHOULD have category are delta data updates and automatic key management for encrypted clients.
\item[COULD have]
    These features are features that will only be implemented if all previous features have been successfully integrated.
    They are not required for the thesis to be considered overly successful but would be nice to have to fully complete the proposed scope.
    Primary aspects that would be added in this phase are a mobile client, most likely as an application for Android, and a web interface for accessing encrypted server clients.
    A further smaller aspect would be shadow file capabilities so that data can be selectively synchronized on constrained devices, specifically mobile devices for example.
\end{description}

\section{Dependencies}

TODO: list, explain reasoning, and list interesting features for all software I'll use to build this.
Notably: Tox, Golang, Hadoop.
Also explain why we use JSON for API.

\section{File Model and API}

The following section will define the data model each peer keeps of its data and specify the API for updating it between peers.
If the model does not match the actual data stored by a client it will try to update the data by requesting the updates from other peers.

For exchanging model information we will specify a JSON based API that will be used to communicate via the Tox text channels.
This API has the goal of being fully scope complete.
This means that both the core model updates required for the basic features of Tinzenite to work and the advanced features must be defined in advance, independent of how far we implement it.

Therefore the following specifications are divided into three parts.
First we will define and explain the model each peer keeps of the stored data.
Next the messages used to facilitate the update of the model between clients will be discussed.
Finally we will take a look at the advanced features and how they will be built on top of the previous work.

\subsection{Peer Data Model}

%TODO: ignore files / dirs? This should be implemented...

% why again json
Since we intend to use JSON for communication via Tox, it seems prudent to define the file model of a peer's data in the same way.
This will allow easy application of updates without having to explicitly translate between two different views of the same data.

An important feature that the model must have is that it works independent of the file types.
Therefore there are only two assumptions we will make of the structure of the directory that a peer will work on: namely that it contains files sorted in directories.
Out of this we can immediately synthesize our two main components we will require: a file model and a directory model.
Since a peer is intended to have directory as the root node from which to run, the core element will always be a directory.
An example of the proposed model structure can be seen in~\ref{fig:modellist}.

\begin{figure}[htp]
\begin{modellist}
\item Root Directory
    \begin{modellist}
        \item File
        \item Sub Directory
            \begin{modellist}
                \item File
                \item File
            \end{modellist}
        \item File
        \item File
    \end{modellist}
\end{modellist}
\caption[Data Model Example Structure]{An example of how a data model of a directory is structured.}
\label{fig:modellist}
\end{figure}

\subsection{Core Update API}

\subsection{Advanced Features API}

TODO: Here is the list of what I consider to be the advanced features.
Now do something sensible with it.

\begin{description}[leftmargin=2em,style=nextline,noitemsep,nolistsep]
\item[Encryption Key Management]
    An important capability will be the synchronization of the access keys to unencrypted clients so that all of them can access the data stored on encrypted clients.
    Thoughts should be given to how to revoke compromised keys.
\item[Space Management]
    The API must respect differences in storage size capabilities between different clients or size restrictions.
    Notably this is important for third parties to sell different storage sizes to clients.
    TODO: could files above the limit be sent as shadow files?
\item[Shadow Files]
    Depending on the location of a client a user may with to only access specific files without having to get an entire set or updates.
    Therefore the client could be set to only read and create dummy files.
    By selecting specific files the client will then only update or retrieve the corresponding files or directories.
    TODO: what to do if a client knows of shadow files but can't get full set?
    Are shadow files also transitively synchronized?
\end{description}

TODO: Test JSON listing so that I know how it looks and works.
Will be used extensively soon.

\begin{lstlisting}[language=json,firstnumber=0]
{
	"test":"json_latex_test"
}
\end{lstlisting}

\section{Software Scope}

TODO: section for listing actual conceptual work I'll have to do before starting implementation

\subsection{Core Application Library}

TODO: all the core logic should be strictly kept separate from the user side of the software.
The library will encapsulate the JSON communication and states of said API.
Clients will have to register hocks for incoming updates, files, and notify the library of updated (delta) files.

To keep development of clients as easy as possible while at the same time keeping the API consisten between them we will separate the core logic for Tinzenite from any user oriented code.
Therefore the library will encapsulate the Toxcore library and build on it the core features required for clients to work.
This means that we will have to define a library API for interfacing with it.
The library will not handle writing or reading data from the user's disk: these capabilities will be offloaded to the implementation of the client programs.
This will ensure a maximum of adaptability for clients, meaning that they will not be constrained by the cross platform capabilities of the library itself.
%TODO of course, Toxcore might pose a problem here... :P

\begin{table}[H]
\centering
%TODO clean table formatting for use everywhere... :P
\begin{tabulary}{\textwidth}{p{2.5cm} || J}
	Initialize & Prepares Tinzenite and starts the underlying libraries, notably connects to the Tox network. Note that once initialized, files will be sent and written immediately. Settings and options must be handed over on initialization.\\
	\hline
    Register Callbacks & Given object will be called for all callbacks.\\
    %TODO: what callbacks should be specificed? register for all should be an option, but registering for any should be possible too!
\end{tabulary}
\caption[Tinzenite Library API]{Methods for accessing the Tinzenite library.}
\label{table:lib:api}
\end{table}

TODO: What about helper functions?
Should be cleanly separate too.
Notably probably includes delta of files, ...?, etc.

\subsection{Client Peer}

TODO: list and explain features of basic computer client (how to connect peers, how to encrypt), remember that usability is important.
Features: password protected everything as with TextSecure?

\subsection{Server Peer}

TODO: write that basically encrypted peer that can handle multiple accounts, stores data via Hadoop.
Future work could include web client – should I add this here too?

\subsection{Mobile Peer}

TODO: write that App, add shadow file feature
