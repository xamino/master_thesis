\chapter{Concept}
\label{chap:concept}

The following chapter discusses all conceptual work that went into creating Tinzenite.
We will first give an overview of the basic goals of this thesis.
Next we will expand on the goals by discussing the features we would like Tinzenite to have and defining their scope.
Then we will give an overview on the software we would like to build on.
Finally we will highlight the features and differences of each software aspect of the Tinzenite system.

\section{Basic Goals}
\label{sec:Basic Goals}

The stated goal of Tinzenite is to offer a peer to peer solution for file synchronization that builds on the strengths of Tox.
It is important to us to build the system in a way that it is secure from unauthorized access by third parties, even if they retain a copy of the data.
In fact we propose an explicit client for third party support so that third parties can offer a storage peer as a service.

Therefore we will need to develop a protocol for a decentralized and distributed system that relies on the underlying secure channel provided.
It seems clear that to minimize developer work we will implement a reference software library for the core protocol.
Expanding on this we hope to implement a peer client for normal computers and a third party client that securely stores the user's data off site.

\section{Features}
\label{sec:Features}

This section will define the features we would like Tinzenite to have, including features that for now go beyond the scope of the thesis.
Therefore we will classify the features by scope for reference afterwards.
The exact features we would like to have have been synthesized from the existing and related work (see section~\ref{chap:Related and Existing Work}).

\begin{description}[leftmargin=2em,style=nextline,noitemsep,nolistsep]
\item[Protocol]
    Design of an extensible protocol on which all communication between peers will be based.
    We will specify the protocol as JSON encoded messages that will be sent as text messages via the Tox protocol.
    The open specification will allow the development of compatible peers by others, important for the extensibility of the system.
\item[Peer to Peer Architecture]
    The complete software suite should run in a direct peer to peer mode to remove the requirement of third parties to facilitate data exchange and to remove the associated security risk.
    This includes the server client as it should be capable of exchanging data even with other server clients.
    As the underlying Tox provides direct peer to peer connections this should be a given from the beginning.
    We also hope that this feature will allow clients to synchronize independently of the internet: peers should be capable of utilizing local connections directly.
\item[Secure Transport]
    All communication between all clients should always be fully end to end encrypted.
    This feature is also provided by the underlying communications software.
\item[Third Party Client]
    A dedicated client for third party servers that holds only an encrypted copy of the data.
    Notable features are that a single instance should handle multiple users' accounts.
    Since large data amounts are to be expected, the server client will be capable of integrating the Hadoop distributed file system to directly support that.
    Support for commercialization of a service based on this client will be provided.
    This includes size and amount distinction based on a per user basis.
    Notably this feature requires peers to authenticate themselves against each other if they are trusted peers.
\item[Shadow Files]
    It should be possible to avoid having to fetch unwanted files for space constrained clients.
    Dubbed shadow objects, this feature could be important for mobile devices as they run on power and bandwidth constraints.
\item[Delta Updates]
    Since it is wasteful to transfer redundant data when only small parts of files are changed, we would like to add the capability to only send the delta difference between two files.
    Note that this is not required for the core functionality but a nice to have optimization.
\item[Object Atomicity]
    We believe that the proposed system should concentrate on one thing and do it well\footnote{Also known as the Unix philosophy.}.
    Therefore we will not touch the content of files, instead treating them as singular objects.
    This should help to guarantee that files are never modified by the system beyond the required operations for synchronization.
    In particular this forbids automatically merging changes in files.
    All conflicts must be resolved by the user: we do not intend to guess the correct resolution strategy for any file type.
\item[Client Agnostic]
    As stated we propose to implement the core protocol functionality in a central library that can be used by different clients independent of their concrete purpose and implementation.
    Therefore we will implement the library as platform agnostic as possible, relying on clients to implement the required file operations and system calls as required.
\item[Concurrency]
    Building on one of the original goals of Golang, we plan on implementing the core library of Tinzenite in an efficient strategy by fully utilizing the language's built in concurrency.
    This should allow Tinzenite to make full use of multi core systems and avoid locking the library up should a single process lock up.
\item[Usability]
    Last but not least in any way we hope to implement reference software in a way that any user can, after the initial setup, use Tinzenite without complex interactions.
    Once the peers for a directory are setup Tinzenite should run as non-intrusive as possible while retaining the user's confidence in the reliability of the system.
    An example for a usability feature might for example be a way to easily authenticate newly connected peers via QR codes or word based hashes instead of the full Tox ID.
\end{description}

There are also features that would be nice to have but are beyond the goal of this thesis.
These include for example the ability to share single files within a synchronized directory with outside users, as seen in Google Drive or Dropbox for example.
This feature is excluded because it requires a more complicated security and encryption model that we do not feel capable of implementing securely.
Security is hard to do correctly, therefore we will limit ourselves before jeopardizing the security of the whole system.

Another feature that would be sensible to have is data obfuscation for encrypted peers.
This would make it even more difficult for nefarious services to extract any information from a hosted encrypted peer.
This would however require a more advanced and distinguished transmission mode for encrypted peers.
Furthermore data deniability is most definitely beyond the capabilities of the proposed implementation (and since the core goal of Tinzenite is data availabilty, somewhat contrary).
If a user allows full access to the directory to an untrusted party there is little that we can do to mitigate the security breach.

Please note that many further features are not dependent on the capability of the Tinzenite system but on the implementation of peers.
An example for this is web access to an encrypted storage: this is a feature that explicitly can be implemented in a secure way\footnote{The key for decrypting the data can be unlocked by the user in the web browser by entering the correct pass phrase. Utilizing the shadow file capability the web application would act as a temporary trusted peer until the user is done with his data access.}.
However we make no guarantee that we will get around to implementing it.

\subsection{Scope}

In this brief section we will go through the exact scope that this work is to fulfill.
We therefore divide the above features into three categories, ranging from required to have the thesis considered successful to those that can be added as extras.
Furthermore we we expand on the actual implementation work we intend for each scope definition.

\subsubsection{MUST Have}
\label{subs:MUST Have}

These features are required for the thesis to be considered basically successful.
This means that the basic fundamentals of the proposed complete scope have been met and are in working order.
Specifically this includes a fully working computer client based on a specified API on which all future work can be built on.
This client must offer the basics required to get the system to work in a user friendly manner from setup through daily usage.
Data transfer between multiple clients must work as expected with collision detection and correct version iteration upon updates.

\begin{description}[leftmargin=13em,style=nextline,noitemsep,nolistsep]
\item[Protocol]
    The core protocol must be fully capable of the basic file synchronization.
\item[Peer to Peer Architecture]
    The base client and library must be capable of running without a centralized system.
\item[Secure Transport]
    All communication must be fully encrypted.
\item[Object Atomicity]
    Files must not be modified by the system beyond the modifications required for the synchronization.
\end{description}

\subsubsection{SHOULD Have}
\label{subs:SHOULD Have}

Features in this category are features that built on the MUST have features and are thus not strictly required.
In broad terms this includes two important aspects.
First and foremost is the capability of having a client that only retains an encrypted version of the data.
Built on this the second aspect is the server client that only ever retains an encrypted data set.
The server also adds the capability of handling multiple users' data on a distributed file system capable of handling the large data size that are to be expected for multiple concurrent users.

\begin{description}[leftmargin=9em,style=nextline,noitemsep,nolistsep]
\item[Third Party Client]
    The capability of supporting encrypted clients should be implemented.
\item[Client Agnostic]
    This feature should be a given once we have started implementation of the second peer program.
\item[Usability]
    The base usage of Tinzenite should be trivial for most users from a usability perspective.
\end{description}

\subsubsection{COULD Have}
\label{subs:COULD Have}

These features are features that will only be implemented if all previous features have been successfully integrated.
They are not required for the thesis to be considered overly successful but would be nice to have to fully complete the proposed scope.
Primary aspects that would be added in this phase are a mobile client, most likely as an application for Android, and possibly even a web interface for accessing encrypted server clients.
A further smaller aspect would be shadow file capabilities so that data can be selectively synchronized on constrained devices, specifically mobile devices for example.

\begin{description}[leftmargin=7.5em,style=nextline,noitemsep,nolistsep]
\item[Shadow Files]
    Peers could be allowed to only fetch files that the user explicitly wishes to have synchronized on a peer basis.
\item[Delta Updates]
    Transfer times of files over limited bandwidths could be optimized by only transferring the differences between them.
\item[Concurrency]
    The core library could support communicating with multiple peers concurrently, thus working around bandwidth constraints.
\end{description}

\section{Dependencies}
\label{sec:Dependencies}

This section briefly highlights the technologies we chose to support our work.
These range from software solutions to data organization standards.

TODO: librsync for the delta file transfer?

TODO: Move this to related work, me thinks.
This has little to do with the concept directly but is a core pillar on what I'll be basing my work on.

\subsection{Tox}

TODO: list, explain

\subsection{Golang}

TODO: list, explain

\subsection{Hadoop}

TODO: list, explain

\subsection{JSON}

TODO: list, explain

\section{Software Scope}
\label{sec:Software Scope}

TODO: section for listing actual conceptual work I'll have to do before starting implementation.
Also consider implementing a working but "quiet" client – no file transfers but reads out communications.

TODO: Or, instead of a quiet client, just start with the protocol implementation before actually enabling Tinzenite to send files.

\subsection{Core Application Library}

TODO: all the core logic should be strictly kept separate from the user side of the software.
The library will encapsulate the JSON communication and states of said API.
Clients will have to register hocks for incoming updates, files, and notify the library of updated (delta) files.

To keep development of clients as easy as possible while at the same time keeping the API consisten between them we will separate the core logic for Tinzenite from any user oriented code.
Therefore the library will encapsulate the Toxcore library and build on it the core features required for clients to work.
This means that we will have to define a library API for interfacing with it.
The library will not handle writing or reading data from the user's disk: these capabilities will be offloaded to the implementation of the client programs.
This will ensure a maximum of adaptability for clients, meaning that they will not be constrained by the cross platform capabilities of the library itself.
%TODO of course, Toxcore might pose a problem here... :P

\begin{table}[H]
\centering
%TODO clean table formatting for use everywhere... :P
\begin{tabulary}{\textwidth}{p{2.5cm} || J}
	Initialize & Prepares Tinzenite and starts the underlying libraries, notably connects to the Tox network. Note that once initialized, files will be sent and written immediately. Settings and options must be handed over on initialization.\\
	\hline
    Register Callbacks & Given object will be called for all callbacks.\\
    %TODO: what callbacks should be specificed? register for all should be an option, but registering for any should be possible too!
\end{tabulary}
\caption[Tinzenite Library API]{Methods for accessing the Tinzenite library.}
\label{table:lib:api}
\end{table}

TODO: What about helper functions?
Should be cleanly separate too.
Notably probably includes delta of files, ...?, etc.

\subsection{Client Peer}

TODO: list and explain features of basic computer client (how to connect peers, how to encrypt), remember that usability is important.
Features: password protected everything as with TextSecure?
Visibility of operations is important.
Will also need to put some thought into support of shadow files – what exactly are they and what happens when I click on one?

\subsection{Server Peer}

TODO: write that basically encrypted peer that can handle multiple accounts, stores data via Hadoop.
Future work could include web client – should I add this here too?

\subsection{Mobile Peer}

TODO: write that App, add shadow file feature

\section{Security Considerations}
\label{sec:Security Considerations}

TODO: place all the security stuff here...
Also note how security has been implemented throughout the concept.
If I place it here I won't have to reexplain it in the architecture chapter.

The peer list is the more problematic of the two as it can be used to determine the size of the user's Tinzenite peer network.
However to allow encrypted peers to facilitate file transfer between two mutually exclusively online peers, it must know this information.
This is mitigated by the fact that Tox IDs are hard to guess and not shared beyond the Tinzenite peer network.
